// Generated by `wit-bindgen` 0.26.0. DO NOT EDIT!
#include "counting.h"
#include <stdlib.h>
#include <string.h>

// Imported Functions from `counting`

__attribute__((__import_module__("$root"),
               __import_name__("print"))) extern void
__wasm_import_counting_print(uint8_t *, size_t);

// Exported Functions from `counting`

__attribute__((__weak__, __export_name__("cabi_post_count"))) void
__wasm_export_counting_count_post_return(uint8_t *arg0) {
  switch ((int32_t)(int32_t) * ((uint8_t *)(arg0 + 0))) {
  case 0: {
    break;
  }
  case 1: {
    if ((*((size_t *)(arg0 + 12))) > 0) {
      free(*((uint8_t **)(arg0 + 8)));
    }
    break;
  }
  }
}

// Canonical ABI intrinsics

__attribute__((__weak__, __export_name__("cabi_realloc"))) void *
cabi_realloc(void *ptr, size_t old_size, size_t align, size_t new_size) {
  (void)old_size;
  if (new_size == 0)
    return (void *)align;
  void *ret = realloc(ptr, new_size);
  if (!ret)
    abort();
  return ret;
}

// Helper Functions

void counting_list_u8_free(counting_list_u8_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    uint8_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
    }
    free(list_ptr);
  }
}

void counting_option_u8_free(counting_option_u8_t *ptr) {
  if (ptr->is_some) {
  }
}

void counting_result_u64_string_free(counting_result_u64_string_t *ptr) {
  if (!ptr->is_err) {
  } else {
    counting_string_free(&ptr->val.err);
  }
}

void counting_string_set(counting_string_t *ret, const char *s) {
  ret->ptr = (uint8_t *)s;
  ret->len = strlen(s);
}

void counting_string_dup(counting_string_t *ret, const char *s) {
  ret->len = strlen(s);
  ret->ptr = (uint8_t *)cabi_realloc(NULL, 0, 1, ret->len * 1);
  memcpy(ret->ptr, s, ret->len * 1);
}

void counting_string_free(counting_string_t *ret) {
  if (ret->len > 0) {
    free(ret->ptr);
  }
  ret->ptr = NULL;
  ret->len = 0;
}

// Component Adapters

__attribute__((__aligned__(8))) static uint8_t RET_AREA[16];

void counting_print(counting_string_t *msg) {
  __wasm_import_counting_print((uint8_t *)(*msg).ptr, (*msg).len);
}

__attribute__((__export_name__("count"))) uint8_t *
__wasm_export_counting_count(uint8_t *arg, size_t arg0, int32_t arg1,
                             int32_t arg2) {
  counting_option_u8_t option;
  switch (arg1) {
  case 0: {
    option.is_some = false;
    break;
  }
  case 1: {
    option.is_some = true;
    option.val = (uint8_t)(arg2);
    break;
  }
  }
  counting_list_u8_t arg3 = (counting_list_u8_t){(uint8_t *)(arg), (arg0)};
  counting_result_u64_string_t ret;
  uint64_t ok;
  counting_string_t err;
  ret.is_err =
      !counting_count(&arg3, option.is_some ? &(option.val) : NULL, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *)&RET_AREA;
  if ((ret).is_err) {
    const counting_string_t *payload4 = &(ret).val.err;
    *((int8_t *)(ptr + 0)) = 1;
    *((size_t *)(ptr + 12)) = (*payload4).len;
    *((uint8_t **)(ptr + 8)) = (uint8_t *)(*payload4).ptr;
  } else {
    const uint64_t *payload = &(ret).val.ok;
    *((int8_t *)(ptr + 0)) = 0;
    *((int64_t *)(ptr + 8)) = (int64_t)(*payload);
  }
  return ptr;
}

// Ensure that the *_component_type.o object is linked in

extern void __component_type_object_force_link_counting(void);
void __component_type_object_force_link_counting_public_use_in_this_compilation_unit(
    void) {
  __component_type_object_force_link_counting();
}
